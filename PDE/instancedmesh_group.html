<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Three.js Hierarchy Editor - Final Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: white; font-family: sans-serif; }
        #info { position: absolute; top: 10px; left: 10px; pointer-events: none; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; user-select: none;}
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="info">
        <h3>계층형 인스턴스 에디터 (완료)</h3>
        <p>큐브 300000개</p>
        <p>1. 클릭: 그룹 -> 하위 -> 개별 (순환)</p>
        <p>2. 허공 클릭: 선택 해제</p>
        <p>3. Gizmo 드래그: 이동 (선택 유지)</p>
        <p id="status">선택 없음</p>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        // --- 전역 변수 ---
        let camera, scene, renderer, controls, transformControl;
        let instancedMesh;
        const count = 30000;
        const dummy = new THREE.Object3D();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // 데이터
        const instanceData = []; 
        const groups = {}; 
        
        // 선택 상태
        let currentSelection = {
            type: null, // 'group', 'subgroup', 'single'
            id: null,   
            memberIds: []
        };
        
        let selectionHelper;
        let previousHelperMatrix = new THREE.Matrix4();

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            
            scene.add(new THREE.GridHelper(100, 10));
            scene.add(new THREE.AxesHelper(10));

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(80, 80, 80);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x666666);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(50, 100, 50);
            scene.add(dirLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Gizmo
            transformControl = new TransformControls(camera, renderer.domElement);
            transformControl.addEventListener('dragging-changed', function (event) {
                controls.enabled = !event.value;
            });
            transformControl.addEventListener('change', updateInstancePositions);
            scene.add(transformControl);

            selectionHelper = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({visible: false}));
            scene.add(selectionHelper);

            generateInstances();

            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointerdown', onPointerDown);

            // 키보드 이벤트로 Gizmo 모드 및 공간 변경
            window.addEventListener('keydown', function (event) {
                switch (event.key.toLowerCase()) {
                    case 't':
                        transformControl.setMode('translate');
                        break;
                    case 'r':
                        transformControl.setMode('rotate');
                        break;
                    case 's':
                        transformControl.setMode('scale');
                        break;
                    case 'l':
                        transformControl.setSpace(transformControl.space === 'local' ? 'world' : 'local');
                        break;
                }
            });
        }

        function generateInstances() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                roughness: 0.3,
                metalness: 0.1
            });

            instancedMesh = new THREE.InstancedMesh(geometry, material, count);
            instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            let index = 0;
            const bounds = { x: 100, y: 50, z: 100 };

            while (index < count) {
                const isGroup = Math.random() > 0.4;

                if (!isGroup) {
                    createInstance(index, null, null, 0xff0000, bounds);
                    index++;
                } else {
                    const groupCX = (Math.random() - 0.5) * bounds.x;
                    const groupCY = (Math.random() - 0.5) * bounds.y;
                    const groupCZ = (Math.random() - 0.5) * bounds.z;
                    const groupRange = 15; 
                    const groupId = `G_${index}`;
                    const groupSize = Math.floor(Math.random() * 10) + 1;
                    const isBlue = Math.random() > 0.5;
                    const baseColor = isBlue ? 0x0000ff : 0xffff00;

                    for (let i = 0; i < groupSize && index < count; i++) {
                        const isSubGroup = Math.random() > 0.6; 
                        if (!isSubGroup) {
                            createInstance(index, groupId, null, baseColor, {x: groupRange, y: groupRange, z: groupRange}, groupCX, groupCY, groupCZ);
                            index++;
                        } else {
                            const subCX = groupCX + (Math.random() - 0.5) * groupRange;
                            const subCY = groupCY + (Math.random() - 0.5) * groupRange;
                            const subCZ = groupCZ + (Math.random() - 0.5) * groupRange;
                            const subRange = 7; 
                            const subGroupId = `S_${index}`;
                            const subGroupSize = Math.floor(Math.random() * 4) + 1; 
                            const isGreen = Math.random() > 0.5;
                            const subColor = isGreen ? 0x00ff00 : 0x800080;

                            for (let j = 0; j < subGroupSize && index < count; j++) {
                                createInstance(index, groupId, subGroupId, subColor, {x: subRange, y: subRange, z: subRange}, subCX, subCY, subCZ);
                                index++;
                            }
                        }
                    }
                }
            }
            instancedMesh.instanceMatrix.needsUpdate = true;
            instancedMesh.instanceColor.needsUpdate = true;
            scene.add(instancedMesh);
        }

        function createInstance(idx, pid, sid, colorHex, range, cx=0, cy=0, cz=0) {
            const x = cx + (Math.random() - 0.5) * (range.x || 1000);
            const y = cy + (Math.random() - 0.5) * (range.y || 500);
            const z = cz + (Math.random() - 0.5) * (range.z || 1000);

            dummy.position.set(x, y, z);
            dummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, 0);
            dummy.scale.setScalar(0.5 + Math.random() * 1.5);
            dummy.updateMatrix();

            instancedMesh.setMatrixAt(idx, dummy.matrix);
            instancedMesh.setColorAt(idx, new THREE.Color(colorHex));

            instanceData[idx] = { id: idx, groupId: pid, subGroupId: sid };

            if (pid) {
                if (!groups[pid]) groups[pid] = [];
                groups[pid].push(idx);
            }
            if (sid) {
                if (!groups[sid]) groups[sid] = [];
                groups[sid].push(idx);
            }
        }

        function onPointerDown(event) {
            // 1. Gizmo 조작 중이면 패스 (클릭으로 간주하지 않음)
            if (transformControl.axis !== null) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersection = raycaster.intersectObject(instancedMesh);

            if (intersection.length > 0) {
                const instanceId = intersection[0].instanceId;
                handleSelection(instanceId);
            } else {
                // 2. 허공 클릭 시 해제
                clearSelection();
            }
        }

        function clearSelection() {
            currentSelection = { type: null, id: null, memberIds: [] };
            transformControl.detach();
            document.getElementById('status').innerHTML = "선택 없음";
        }

        // [핵심 수정] 드릴다운 로직을 명확하게 분기 처리
        function handleSelection(instanceId) {
            const data = instanceData[instanceId];
            if (!data) return;

            let nextType = 'group';
            let targetId = data.groupId;

            // 1. 독립 객체인 경우 (빨간색 등)
            if (!data.groupId) {
                nextType = 'single';
                targetId = instanceId;
            } 
            // 2. 그룹 소속인 경우
            else {
                // 현재 [최상위 그룹]이 선택된 상태라면?
                if (currentSelection.type === 'group' && currentSelection.id === data.groupId) {
                    // -> 서브그룹이 있으면 서브그룹으로, 없으면 개별로
                    if (data.subGroupId) {
                        nextType = 'subgroup';
                        targetId = data.subGroupId;
                    } else {
                        nextType = 'single';
                        targetId = instanceId;
                    }
                }
                // 현재 [서브 그룹]이 선택된 상태라면?
                else if (currentSelection.type === 'subgroup' && currentSelection.id === data.subGroupId) {
                    // -> 개별 선택으로
                    nextType = 'single';
                    targetId = instanceId;
                }
                // 아무것도 선택 안 됐거나, 다른 그룹을 클릭했다면?
                else {
                    // -> 최상위 그룹 선택 (기본값)
                    nextType = 'group';
                    targetId = data.groupId;
                }
            }

            applySelection(targetId, nextType, instanceId);
        }

        function applySelection(targetId, type, clickedInstanceId) {
            let members = [];
            if (type === 'single') {
                members = [clickedInstanceId];
            } else {
                members = groups[targetId] || [clickedInstanceId];
            }

            currentSelection = { type: type, id: targetId, memberIds: members };

            document.getElementById('status').innerHTML = 
                `선택됨: <span style="color:orange">${type.toUpperCase()}</span> (ID: ${targetId})<br>객체 수: ${members.length}`;

            // Gizmo 중심점 계산
            const center = new THREE.Vector3();
            const tempPos = new THREE.Vector3();
            members.forEach(id => {
                instancedMesh.getMatrixAt(id, dummy.matrix);
                tempPos.setFromMatrixPosition(dummy.matrix);
                center.add(tempPos);
            });
            center.divideScalar(members.length);

            // Helper를 항상 월드 축에 정렬하여 '점프' 현상 방지
            selectionHelper.position.copy(center);
            selectionHelper.quaternion.set(0, 0, 0, 1);
            selectionHelper.scale.set(1, 1, 1);
            
            selectionHelper.updateMatrixWorld();
            transformControl.attach(selectionHelper);

            // 다음 프레임의 변환 계산을 위해 현재 행렬을 저장
            previousHelperMatrix.copy(selectionHelper.matrixWorld);
        }

        function updateInstancePositions() {
            if (!currentSelection.memberIds.length || !transformControl.object) return;

            const tempMatrix = new THREE.Matrix4();
            const deltaMatrix = new THREE.Matrix4();

            // 이전 프레임 대비 현재 프레임의 Gizmo 변환량(deltaMatrix)을 계산
            // deltaMatrix = currentHelperMatrix * inverse(previousHelperMatrix)
            tempMatrix.copy(previousHelperMatrix).invert();
            deltaMatrix.multiplyMatrices(selectionHelper.matrixWorld, tempMatrix);

            // 계산된 변환량을 모든 그룹 멤버에 적용
            const instanceMatrix = new THREE.Matrix4();
            currentSelection.memberIds.forEach(id => {
                instancedMesh.getMatrixAt(id, instanceMatrix);
                instanceMatrix.premultiply(deltaMatrix);
                instancedMesh.setMatrixAt(id, instanceMatrix);
            });

            instancedMesh.instanceMatrix.needsUpdate = true;

            // 다음 프레임 계산을 위해 현재 Gizmo 상태를 저장
            previousHelperMatrix.copy(selectionHelper.matrixWorld);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>